import os
import json
from fastapi import APIRouter, HTTPException, Depends, Request
from pydantic import BaseModel, Field
from typing import Dict, List, Any
import logging # Added logging

import google.generativeai as genai # Added for Gemini

# --- Pydantic Models ---
class CodingAgentRequest(BaseModel):
    visual_generation_prompt: str = Field(
        ..., 
        description="The detailed prompt generated by the VisualPromptGeneratorAgent, intended for a code-generating LLM."
    )
    chosen_visual_type: str # Passed through for context, might be useful for logging or minor adjustments

class CodingAgentResponse(BaseModel):
    html_code: str = Field(default="", description="The generated HTML code for the visual.")
    css_code: str = Field(default="", description="The generated CSS code (if separate, otherwise empty if embedded in HTML).")
    js_code: str = Field(default="", description="The generated JavaScript code (if separate, otherwise empty if embedded in HTML).")
    chosen_visual_type: str

logger = logging.getLogger(__name__) # Added logger instance

# --- Prompt Templates for Engineering Visualizations ---
ENGINEERING_PROMPT_GUIDELINES = '''
You are an expert educational visualization generator. For any engineering field (CSE, Mechanical, Electrical, AI, Civil, etc.), generate a complete, responsive, and visually attractive HTML visualization.
- Use modern, colorful, and accessible UI design.
- The visualization must be fully responsive (works on mobile and desktop).
- Return ONLY the HTML code (no explanations, markdown, or extra text).
- Your response must start with <!DOCTYPE html> and end with </html>.

Specialized Scenarios:
A. Roadmap (Flowchart/Mindmap):
    - Generate a colorful, interactive, and responsive flowchart or mindmap for the roadmap of a [FIELD] engineering student.
    - Use HTML, CSS, and JavaScript only.
    - Make the nodes clickable to show more info.
    - Use distinct colors for each branch or topic.
    - Return ONLY the HTML code.
B. Subject Overview (Grid/Infographic):
    - Create a responsive, colorful infographic or grid layout showing the core subjects and their relationships for [FIELD] engineering.
    - Use cards or tiles for each subject.
    - Add icons and color coding.
    - Return ONLY the HTML code.
C. Process/Workflow (Step-by-Step/Timeline):
    - Visualize the [PROCESS] in [FIELD] engineering as a step-by-step timeline or process diagram.
    - Use a horizontal or vertical timeline.
    - Make it visually engaging and easy to follow.
    - Return ONLY the HTML code.
D. Comparison Chart:
    - Build a responsive, colorful comparison chart between [TOPIC 1] and [TOPIC 2] in [FIELD] engineering.
    - Use tables, cards, or side-by-side panels.
    - Highlight differences with colors and icons.
    - Return ONLY the HTML code.
E. AI/ML Model Pipeline:
    - Create a responsive, interactive pipeline diagram for a typical AI/ML workflow in [FIELD] engineering.
    - Use modern design, color coding, and tooltips.
    - Return ONLY the HTML code.
F. Algorithm Simulation:
    - For algorithm simulations, use an iterative, interactive approach: build the simulation step by step, with clear state updates and user controls (start, pause, reset, speed, etc.).
    - Generate a fully interactive, real-time visualization (e.g., animated sorting, pathfinding, etc.) that fills the available width and height of the chat section.
    - Use a <canvas> or <svg> that resizes responsively.
    - Include controls (start, pause, reset, speed, etc.) and display the current state/step.
    - Make the design visually rich, with multiple elements, color coding, and tooltips.
    - Do NOT generate simple diagrams with only one or two boxesâ€”make the visualization complex and educational.
    - The simulation must work in a React app using dangerouslySetInnerHTML. Avoid document.write, window.open, or direct DOM manipulation outside the root element.
    - WARNING: If your simulation does not render or function correctly, your output will not be accepted.

General Instructions:
- For every visualization type you suggest, you must know how to build it and include all necessary elements for a rich, interactive, and educational experience.
- Use color, animation, and interactivity to make the visualization engaging and educational.
- WARNING: If you do not follow these instructions, your output will not be accepted.
- TIP: The more interactive, colorful, and educational your visualization, the better.

When fixing code, the code fixer agent must use these same guidelines to ensure the fixed code is also complex, interactive, responsive, and visually appealing.
'''

# --- Updated Dependency Function to get Gemini Client ---
def get_gemini_client(request: Request) -> genai.GenerativeModel:
    if not hasattr(request.app.state, 'gemini_client') or request.app.state.gemini_client is None:
        logger.error("Gemini client not found on app.state in coding_agent")
        raise HTTPException(status_code=503, detail="LLM service (Gemini) not available (CodingAgent).")
    return request.app.state.gemini_client

# --- Core Agent Logic (Updated for Gemini) ---
def extract_code_from_llm_response(llm_output: str) -> str:
    """Extracts code block assuming it's wrapped in ```html ... ``` or similar."""
    # Remove markdown code fences and explanations, keep only HTML
    import re
    html = re.sub(r'^```html\\s*', '', llm_output.strip(), flags=re.IGNORECASE)
    html = re.sub(r'^```', '', html, flags=re.MULTILINE)
    html = re.sub(r'```$', '', html, flags=re.MULTILINE)
    # Remove everything before <!DOCTYPE html>
    html = re.split(r'<!DOCTYPE html>', html, flags=re.IGNORECASE)[-1]
    html = '<!DOCTYPE html>' + html
    # Remove anything after </html>
    html = re.split(r'</html>', html, flags=re.IGNORECASE)[0] + '</html>'
    # Remove any trailing explanations or comments after </html>
    html = re.split(r'</html>', html, flags=re.IGNORECASE)[0] + '</html>'
    # Remove any leading explanations or comments before <!DOCTYPE html>
    html = re.split(r'<!DOCTYPE html>', html, flags=re.IGNORECASE)[-1]
    html = '<!DOCTYPE html>' + html
    return html.strip()

async def generate_visual_code(
    prompt_for_code_llm: str, 
    gemini_client: genai.GenerativeModel # Updated type hint
) -> str:
    # Prepend the engineering visualization guidelines to every prompt
    full_prompt = ENGINEERING_PROMPT_GUIDELINES + '\n' + prompt_for_code_llm
    logger.info(f"Sending request to Gemini for CodingAgent. Prompt length: {len(full_prompt)}")
    try:
        coding_agent_temp = float(os.getenv("CODING_AGENT_TEMPERATURE", "0.1")) 
        generation_config = genai.types.GenerationConfig(
            temperature=coding_agent_temp,
        )
        response = await gemini_client.generate_content_async(
            full_prompt, 
            generation_config=generation_config
        )
        if response.text:
            raw_llm_output = response.text
            logger.debug(f"Coding Agent Gemini raw response snippet: {raw_llm_output[:200]}...")
            extracted_code = extract_code_from_llm_response(raw_llm_output)
            if not extracted_code.strip():
                 logger.warning("Code extraction resulted in empty string, though LLM provided response. Raw output might be missing code fences or content.")
                 logger.debug(f"Full raw output from LLM for empty extraction: {raw_llm_output}")
            return extracted_code
        else:
            logger.error(f"Coding Agent: Gemini returned no text. Feedback: {response.prompt_feedback}, Finish: {response.candidates[0].finish_reason if response.candidates else 'N/A'}")
            if response.prompt_feedback:
                raise HTTPException(status_code=400, detail=f"Request blocked by Gemini (CodingAgent) due to: {response.prompt_feedback.block_reason}")
            if response.candidates and response.candidates[0].finish_reason != 'STOP':
                 raise HTTPException(status_code=500, detail=f"LLM (CodingAgent) generation finished unexpectedly: {response.candidates[0].finish_reason}")
            raise HTTPException(status_code=500, detail="Coding Agent: LLM (Gemini) returned no content.")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Coding Agent: Error during Gemini LLM call: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Coding Agent: An error occurred with LLM (Gemini): {str(e)}")

# --- FastAPI Router ---
router = APIRouter() # Removed prefix and tags

@router.post("/generate-code", response_model=CodingAgentResponse)
async def generate_code_endpoint(
    request_data: CodingAgentRequest,
    gemini_llm_client: genai.GenerativeModel = Depends(get_gemini_client) # Use new dependency
):
    """
    Generates HTML, CSS, and JavaScript code for a visual based on a detailed prompt using Gemini.
    """
    if not request_data.visual_generation_prompt.strip():
        raise HTTPException(status_code=400, detail="visual_generation_prompt cannot be empty.")

    generated_code_str = await generate_visual_code(
        prompt_for_code_llm=request_data.visual_generation_prompt, 
        gemini_client=gemini_llm_client # Pass gemini_client
    )
    
    if not generated_code_str.strip():
        logger.warning("Coding Agent: generate_visual_code returned empty or whitespace string.")
        # Return empty codes but still a 200, client can decide if this is an error state
        return CodingAgentResponse(
            html_code="", 
            css_code="", 
            js_code="", 
            chosen_visual_type=request_data.chosen_visual_type
        )

    # The prompt asks for a single block of HTML with embedded CSS and JS.
    # So, we put the entire extracted code into html_code.
    return CodingAgentResponse(
        html_code=generated_code_str,
        css_code="", # Assuming CSS is embedded within the html_code
        js_code="",  # Assuming JS is embedded within the html_code
        chosen_visual_type=request_data.chosen_visual_type
    ) 